#+TITLE:Frequently Asked Questions
#+AUTHOR:Frequently Asked Questions
#+SUBTITLE:Frequently Asked Questions All Courses @Lyon Fall 2021
#+OPTIONS: ^:nil toc:1
#+STARTUP: overview
* What is this?

  This is a Frequently Asked Questions (FAQ) file for all my courses
  at Lyon College. For individual FAQs, see the resp. course repos.

* How should you read?
  There are different ways to read a demanding text. Since I
  systematize everything, let me try to systematize this for you,
  too - even though reading is quite a personal activity (involving,
  for example, taste), I believe that it is useful to have a system
  if your goal is to learn the most with the least effort[fn:1]. In
  the following, you can substitute "read" for "learn using media":
  instead of a printed book, you can also use a digital book, a
  podcast, or a video[fn:2]. I can think of (1) skimming; (2) shallow
  reading; (3) deep reading; (4) reading with notes; (5) reading with
  props; (6) re-reading. What are these about?

  1) *Skimming*: quickly go over the material in an intuitive fashion
     to decide what to do with it later, or to get at least a basic
     idea of what's being said. For scientific papers: read abstract,
     then (if still interesting) go to the conclusions at the end.

     [[https://github.com/birkenkrahe/org/blob/master/img/ai_shallow.gif]]

  2) *Shallow reading:* read through the whole text slowly, without
     too many breaks[fn:3], in order to get a general picture and
     already identify areas of information (to answer questions like:
     am I too ignorant to understand this? What do I already know? How
     long will it take me to fully unlock this text? Will it be worth
     it?).

  3) *Deep reading:* Deep reading implies not taking breaks and
     holding the tension of not understanding. The only break that I
     allow myself for this mode of reading is to take my eyes off the
     text to think. The point is not to break concentration, because
     if you want to summon your full forces of association, you need
     to immerse yourself in the material. Deep reading almost always
     leaves me hungry for the next reading stage (reading with notes),
     or for reading something else too, or instead (e.g. if the text
     was inspiring and interesting, but just too hard to understand
     without working through it in its entirety).

  4) *Reading with notes:* This mode and the next are the most
     time-intensive ones. I employ them whenever I am working out a
     lecture, or practice exercises, or if I find something really
     hard of I am puzzled or stumped[fn:4]. I find it important to
     write everything with long hand in a proper notebook (lined,
     21x31, softcover). I use a lovely fountain pen with black ink and
     a converter that I have to refill by hand). Writing in this
     notebook feels good and I like looking at my notes afterwards,
     which is important, even though most of these notes will never be
     looked at again: the point is not to duplicate the text but to
     get it into my head. I find that taking digital notes does not
     compare with analog notes. From all of this, you can discern that
     the way of taking notes is quite personal and cannot be part of
     the (universal) system. You may prefer to write with a pencil on
     individual sheets of yellow squared paper, or in a college block,
     or with a brush on hand-made Japanese paper. It doesn't matter.

     For example, here are two pages of "reading with notes" based on
     a series of four short videos in the Coursera course "[[https://www.coursera.org/learn/model-thinking/home/welcome][Model
     Thinking]]", which I used to prepare a lesson in a new course on
     "data modeling":

     [[https://github.com/birkenkrahe/org/blob/master/img/ai_notes.jpg]]

  5) *Reading with props:* Often, especially in computer science,
     writing about concepts, and making computations by hand, is not
     enough. I have to try stuff as I read[fn:5] using props. The
     props lead to interactive (digital) notes rather than static
     (analog) ones. Any additional medium that I use (e.g. mindmaps,
     wiki, post-its, presentation) takes me away from the text and
     offers additional distractions - hence, I must have a really good
     reason to do this. More often than not, this mode is a follow-up
     mode to deepen my knowledge and my familiarity with a
     topic[fn:6].

     For example, here are two pages from the book "[[http://aima.cs.berkeley.edu/][Artificial
     Intelligence - a Modern Approach]]" (AIMA) and the corresponding
     "reading with props" notes in the Emacs editor.

  https://github.com/birkenkrahe/org/blob/master/img/ai_aima.jpg

  https://github.com/birkenkrahe/org/blob/master/img/ai_emacs.png

  6) *Re-reading:* I often have to do this, because my memory is
     leaky. Re-reading is like skimming (1) except that I (should)
     know the text really well already and only need to remind myself
     of core content and issues. Some instructors require re-reading -
     e.g. Bjarne Stroustrup, for his [[https://www.stroustrup.com/programming.html][introductory programming course]],
     writes that the student must read the section of the book
     relevant to a session both before and after the session. I think
     this is excellent advice, because the second reading often
     reveals additional issues, and can be much more pleasurable,
     since you should now have a much better understanding. Of course,
     this only works if the text is well written[fn:7].

  7) *What now?* For example, how can you know if you've "read well"?
     In my experience, there is only one way: you've got to be able to
     create problems for yourself and solve them. Start with small
     problems (extensions of the text) and then move on to bigger
     ones. A concrete example from my reading of the AIMA book are
     questions that I ask myself as I'm reading, and that are not
     answered in the text (or even mentioned), e.g. "When did the
     concept of 'intelligence' become common?", or What is
     "first-principles reasoning"? (The term was used but not
     explained) etc. These are almost glossary-type questions. For
     another book that I'm working through ([[https://rafalab.github.io/dsbook/probability.html][on probability theory]]),
     I'm trying to work out answers to simple questions that are
     extensions of examples given in the text. Also, if you are ever
     in a situation to teach, or even instruct, others on anything you
     learnt (which is likely if you are in a leadership role), this
     ability to construct assignments and exercises for practice will
     come in very handy. Caveat: this activity takes much longer than
     even "reading with notes" - in my case, I sometimes spend an
     entire day devising problems and trying to solve them, when the
     reading and note-taking only took me an hour!

* How can you read more research papers?

  The title comes from [[https://www.louisbouchard.ai/research-papers/][this article]] by Louis Bouchard (23 June
  2021)[fn:9]. It's useful and you should all read it and take from it what
  you want. Here, I'm offering a few comments, organized by the
  different stages addressed in the article.

  First of all, the problem: a lot is published on any topic under the
  sun, and a lot more if the topic is trendy - like machine
  learning. This is both good and bad news. The good news: many
  publications means that the respective field is evolving fast,
  attracting the best people, research money, and generating a market
  (for products and people). The bad news: more and more publications
  remain essentially unchecked and unread; many of these papers are
  badly written, many are wrong, some are fraudulent even. There is so
  much pressure on the publication pipeline that hundreds, or
  thousands of papers are rushing past you in the blink of an eye.

  There are several questions resulting from this problem: (1) how to find
  the best papers? (2) How to find the papers that are right for you?

  The article mentioned only addresses the second question in
  detail. The first question is touched upon in a paragraph on bias
  and trustworthiness at the end. In short: don't trust anyone until
  you've checked the results yourselves[fn:10].

  The author's answer to the first question is based on a series of
  software tools that can support your search. I only knew 2 of these
  (Arxiv Sanity Preserver and Zotero).

  Missing: conference reports via the relevant conferences, especially
  literature reviews, and [[https://www.kcu.edu/wp-content/uploads/2014/09/Google-Scholar-Alert.pdf][Google scholar alerts]]. E.g. I have an alert
  out for every one of my current courses and research interests. It
  is connected with [[https://scholar.google.com/citations?hl=en&user=Vvnwsv0AAAAJ][my Google Scholar profile]].

  The final advice is excellent: you only get better at reading papers
  by reading papers!

* Why are we using GitHub?

  We're using GitHub for two reasons:

  1) GitHub will be our infrastructure for course materials and
     assignments.
  2) GitHub uses Git, the state-of-the-art version control system,
     which is an important development productivity tool.

  Git is open source software, and used by many platforms like
  GitHub - e.g. GitLab, BitBucket, Sourceforge, [[https://www.git-tower.com/blog/git-hosting-services-compared/][and many more]]. GitHub
  is now owned by Microsoft, but it supports education (with GitHub
  classroom), and it is still the largest hosting platform for open
  source projects (and I love anything open source). Many books and
  tutorials use GitHub for code delivery, errata and updates -
  technical books are products that benefit from version control, too!

  Here is a link to [[https://github.com/birkenkrahe][my GitHub account]], which I use mostly for my
  courses ([[https://github.com/birkenkrahe/ds101][like this one]]), to fork other people's repos ([[https://github.com/matloff/fasteR][like this
  one]]), and to learn stuff ([[https://github.com/education/github-starter-course][like this one]]).

  I've [[https://github.com/settings/billing/plans][upgraded]] my GitHub account, by the way, e.g. to see traffic
  data, for better workflow control (with [[https://docs.github.com/en/actions/quickstart][GitHub actions]]), and for
  data science (e.g. via [[https://ghtorrent.org/][GHTorrent]] and [[https://www.gharchive.org/][GH Archive]]).

* What is version control?

  Version control refers to professionally managing software
  versions. Though an old hat as such, it was revolutionized by Git,
  which was created by Linus Torvalds, the creator (and still core
  developer-king) of the Linux kernel. It transferred the same idea on
  which the Web is founded (local control, global availability) to
  software development. Before Git, I worked with CVS ([[https://www.cs.umb.edu/~srevilak/cvs.html][Concurrent
  Version control System]]), which does what Git does, except that it
  focuses on the central repository rather than on the local
  repository. Most of the workflow - initializing a repo, checking
  files in (staging), checking files out, committing files to the
  repo, checking the status, showing differences, merging versions
  etc. carries over from other version control systems. Here is a
  [[https://www.linkedin.com/pulse/difference-between-git-cvs-ahmed-el-emam/][direct comparison of CVS and Git]] (2017).

* How should you use GitHub?

  Notice that there are a myriad of tutorials, text, courses, and
  videos, out there already. What I'm explaining here focuses on the use
  of Git and GitHub in my courses, nothing more.

  For my courses, you need to:

  1) *install* Git locally (i.e. on your work computer)
  2) *initialize* Git locally in a repository ("repo")
  3) *register* a GitHub account (don't use your real name!)[fn:12]
  4) *send me* your account name so that I can add you[fn:11]
  5) *upload* your files to my repo when requested to do so
  6) *raise* a repo issue to comment upon something [optional][fn:13]
  7) *discuss* in your course discussion forums [optional]
  8) *fork* my repo to your GitHub account [optional][fn:14]
  9) *create* your own (private or public) repo [optional]
  10) *invite* me as a collaborator to your repo [optional]

  You can also use the "Project" facility in GitHub to manage your
  projects using a simple Kanban board (or define a more complicated
  workflow if you like). I will show all of this in class.

* What is a sprint review?

  A sprint review (a Scrum term - see [[https://www.scrum.org/resources/scrum-glossary][Scrum glossary]]) is an informal
  presentation of the results obtained during the last sprint, or work
  period. What you present is also called a "prototype" to accentuate
  the fact that you're working incrementally towards a final product.

  More important than the presentation itself is the dialog with the
  customer or "product owner" (in Scrum speech), at least before the
  final sprint review (the presentation of the final result).

  If you don't work on a software product, or if you don't work in a
  team (because you're writing an essay), the same rules apply but
  rather than be a slave to the Scrum idea, you adapt it to your
  needs. That's what companies do in practice all over the place.

  The sprint reviews themselves are not graded, though your
  participation will be, and you have to deliver a sprint review, even
  if you could not complete a result during the last sprint.

* What do I need to deliver at a sprint review?

  You should put your sprint review results on slides, which you need
  to upload to the specified location on time. Details in class.

  The following questions should be covered in a sprint review:

  1) What did we want to achieve in the last sprint?
  2) What did we achieve in the last sprint?
  3) What are we especially proud of in the last sprint?
  4) What did we not achieve in the last sprint?
  5) What are we going to do different in the next sprint?
  6) What are our questions to the product owner?
  7) What are our questions to the other teams?

  These questions may not all apply equally. You can use them to
  structure your presentation though you should feel free to be
  creative and mix them up. Remember that the purpose of the sprint
  review is dialog, not a perfect performance or a perfect product.

* What should we do in the first sprint?

  In the first sprint, focus on QUESTION - what do you want to find
  out, and who'll care (who is the beneficiary, apart from you)? The
  most important deliverable is the research question (with sub
  questions, perhaps with one or more testable hypotheses) that says
  what exactly you wish to investigate.

  The research question must be validated by a literature review,
  and/or by primary data in the form of expert views. These views can
  be primary data (generated by you, e.g. through an interview), or
  secondary data (e.g. a podcast where an expert was
  interviewed).

  In data science, authors are often blissfully unaware of the need to
  embed research in a scientific context. This is not good (though
  common especially in new disciplines, who are high on new
  discoveries and free exploration), and can even be dangerous (can
  you see why?). We'll discuss good examples in class - if you find
  any, share them!

  The first sprint covers the "I" (for Introduction) of the IMRaD
  structure of scientific papers (see FAQ).

* What should we do in the second sprint?

  In the second sprint, focus on METHOD. The most important deliverable
  is an account of how exactly you want to analyze the datasets that are
  relevant to your research question.

  Method also needs to be validated (same as the research question).
  Some authors do not justify their method other than by applying it -
  as if getting a result was justification enough. This is not true,
  not good, and can even be dangerous (can you see why?). We'll
  discuss good examples in class - if you find any, share them!

  "Method" is often not taught in college. It is assumed that this is
  more of a graduate or post-graduate necessity. Far from it. If you
  cannot say why you applied a certain strategy during your research,
  you may not be aware of different, potentially better, methods.

  The second sprint covers the "M" (for "Method") of the IMRaD structure
  of scientific papers (see FAQ).

* How do you report on and plan a research "method"?

  The focus of the second sprint review is "method", i.e. the "how" of
  your research process. The main deliverable in this case is a
  research report (a written essay) of moderate length (2,500-5000
  words).

  So what does "reporting on method" mean? Generally speaking it means
  that you need to inform the audience what exactly you plan to do in
  the course of your research, and convince them that you've chosen well.

  Let's look at an example - a short conference paper that I wrote on
  storytelling ([[https://github.com/birkenkrahe/mod482/blob/main/6_storytelling/IEEE-ICCI-CC-14-BIRKENKRAHE.final_copy.pdf][Birkenkrahe, 2014]]). The main achievement of this paper
  is - you guessed it - a model, shown in the figure below.

  [[./img/model.png]]

  The main purpose of the paper was to research my hypothesis that the
  storytelling arc (e.g. in a traditional novel) can be mapped onto
  the IMRaD structure for scientific papers.

  My methods of investigation were:

  1) a short *literature review*. This review looked at publications
     that were also sitting "on the fence" between science and fiction
     writing. It was short because there wasn't very much. Most
     authors didn't think that writing in science and writing in
     fiction had much in common.
  2) data from a collection of *personal examples*, gathered in the
     course of a few years before this research. They included my own
     fiction writing and supervising students' writing (in a number of
     different settings).
  3) the outline of a *planned experiment* with students of a new
     course.

  My methods therefore included checking work done by others (1),
  analyzing my own experiences (2), and making a plan for testing my
  model in a real setting (3).

  Hopefully, this structural breakdown will help you think about your
  modeling paper.

* What should we do in the third sprint?

  In the third sprint, focus on getting RESULTS. This is highly
  dependent on your research question and on your product type. Let's
  look at only one example here - an EDA or Exploratory Data Analysis
  of a dataset.

  There are many different ways of analyzing a dataset (in the light
  of your research question or, as it were, free form, following a
  scent, guided by invisible hands, feeling creative) - some of which
  you will have seen in the course by the time this sprint review
  rolls around. Examples include: statistical summaries, functions,
  contingency tables, plots of various types (histograms, barplots,
  heatmaps, scatterplots, regression plots), and descriptions. Which
  are relevant here depend entirely on your data and on your research
  question. This part of the EDA is the playful part, only restricted
  by your technical prowess. Hence, you can draw on a myriad of
  examples in blogs, papers, etc.

  The variety of results in this example carries over to other types
  of results - e.g. a literature review (of a bunch of papers, or of a
  book), or an application concept. The result is pretty much anything
  you've been able to find out so far using the tools you committed to
  use (your method).

  The Third sprint covers the "R" (for "Results") of the IMRaD
  structure of scientific papers. (See FAQ.)

* What should we do in the fourth sprint?

  In the fourth and final sprint, focus on the MEANING of your
  analysis. Your most important deliverables are: an interpretation of
  the data, perhaps a discussion of your hypotheses (if you had any
  explicit hypotheses).

  A decisive activity of this sprint is the comparison with existing
  literature (which you have gathered in the first sprint, and watched
  ever since), and/or expert views (which you have solicited and
  watched ever since).

  Another important aspect of this sprint are the LIMITATIONS - a
  thorough description of your sources of bias and what to do about
  it.

  Finally, you can also provide an OUTLOOK - interesting avenues for
  further investigations. Notice that some papers (and virtually all
  blog posts and other non-scientific articles) are missing a
  (non-trivial) discussion of bias. This is not good, and always
  dangerous (can you see why?).

  Many EDAs (at least in non-scientific publications) are also missing
  a comparison with existing literature, which means that, as the
  reader, you have no idea if what you're reading is original,
  relevant or important at all. No investigation is an island.

  The fourth sprint covers the "D" (for "Discussion") of the IMRaD
  structure of scientific papers. See FAQ for more on IMRaD.

* Where I can find out more about "IMRaD"?

  See [[https://youtu.be/dip7UwZ3wUM][this short (15 min) YouTube video]] - produced for a course on
  "research methods" for graduate students at the Berlin School of
  Economics and Law (MBAs). See also my paper on storytelling and
  scientific writing ([[birk14][Birkenkrahe, 2014]]).

  The structural similarity between storyline and other successful
  forms of writing (like in science) is actually not surprising when
  you think about it. Whatever you may think about progress - some
  things were found to be true long ago (e.g. the most effective form
  for a story - by Aristotle, 2500 years ago), and they still work as
  well, or better, than many inventions that came after them.

  You may perhaps wonder why nobody has told you about "IMRaD" before:
  all scientists and scholars use it, but not all reflect upon their
  writing, I think, at least in the STEM disciplines.

* Which editor and IDE do you use?

  I use the free [[https://www.gnu.org/software/emacs/][Emacs]] editor. For R, I use Emacs + [[https://ess.r-project.org/][ESS]] ("Emacs Speaks
  Statistics"), for general notebooking and task management
  and...everything really, I use Emacs + ESS + [[https://orgmode.org/][Org-mode]] (a
  general-purpose task manager inside Emacs, first developed by
  physicists like me). For slides, I use the [[https://github.com/hakimel/reveal.js/][reveal.js]] (JavaScript)
  framework (generates HTML), or [[https://github.com/takaxp/org-tree-slide][org-tree-slide]] (for presenting
  straight from Org-mode).

  Emacs is hands down the best editor in the world, written in [[https://en.wikipedia.org/wiki/Lisp_(programming_language)][LISP]][fn:2],
  one of the earliest programming languages for AI research, and the
  second oldest language in widespread use (after FORTRAN).

  They say the learning curve of this "complex beast" ([[https://masteringemacs.org/article/beginners-guide-to-emacs][Petersen, 2019]])
  is steep but don't believe it.  Here is an link to [[https://opensource.com/article/20/3/getting-started-emacs][get started with
  Emacs easily]] (Kenlon, 2019). Tale a look!

  Here is a 2021 "[[https://ess-intro.github.io/][Introduction to Emacs Speaks Statistics]]" site with
  lots of additional information.

  Thee figure [[fig:emacs]] shows four (out of an arbitrary number of)
  panels inside the editor

  #+name: fig:emacs
  https://github.com/birkenkrahe/dsc101/blob/main/img/emacs.png

* How can I install Emacs as a data science IDE on Windows 10?

  GNU Emacs is a free, extensible editor written in a dialect of Lisp,
  a programming language that used to be the main language for
  Artificial Intelligence applications (besides PROLOG) until Python
  and R came along. After my Linux laptop went on the fritz, I
  switched to a Windows 10 box myself. Since most if not all of you
  are committed Windows users, I decided to stay down there with
  you. As a consequence, I had to figure out how to run my favorite
  development environment, Emacs + ESS + R, under this OS. Here are
  the steps I used to do that. Let me know if this works for you!

** Download and install Emacs + ESS

   For Windows, you can download and install the latest Emacs version
   bundled with Org-mode and ESS from here:
   https://vigou3.gitlab.io/emacs-modified-windows/

   The installation is standard and worked without a hitch. Put a
   launcher/link to Emacs on the Desktop and on your tasklist. Open
   Emacs.

** Emacs tutorial

   The first thing you need to do is to complete the Emacs onboard
   tutorial. Open it from the Startup screen, or open it any time with
   the key sequence ~<CTRL>-h t~. These key sequences will take some
   time to get used to but once you got them in your fingers, you
   won't want to look back, because you're going to be much faster
   than any mouse. 

** Download and install R

   You only need to do this if you want to work with R. Even if you
   don't, you can use Emacs to develop programs in any language, or
   use Org-mode to run your life more merrily.

   Download R from ~rproject.org~ for Windows and do a standard
   installation. Launch R independently from Emacs to test that it
   works. Try to plot something with ~plot(rnorm(100))~ to test the
   graphic device.

** Set the ~PATH~ environment variable

   You have to pass the path to the R executable to Windows so that it
   can find it when Emacs asks for it. To do this, open the Shell in
   Emacs with ~M-x shell~, type ~PATH~ to see the current load path,
   and then add that (absolute) folder address with ~PATH=~. This is
   how it looks for me:

   #+begin_example sh
PATH=C:\Windows\system32;C:\Windows;C:\Windows\System32\Wbem;C:\Windows\System32\WindowsPowerShell\v1.0\;C:\Windows\System32\OpenSSH\;C:\Users\birkenkrahe\AppData\Local\Microsoft\WindowsApps;C:\Users\birkenkrahe\AppData\Local\GitHubDesktop\bin;C:\Users\birkenkrahe\Documents\R\R-4.1.0\bin\x64;
   #+end_example

** Test run your new setup

*** Opening R

    Open R with ~M-x R~. Emacs asks if you want to open R in the
    current directory (which is the folder you can get with ~getwd()~
    inside R.

*** Running R from the shell inside Emacs

    Frankly, I don't know which shell program Emacs uses here. I
    suspect it is the Microsoft PowerShell - something else that I
    need to figure out on a rainy afternoon. You can start the shell
    inside Emacs with ~M-x shell~ and then run R inside it.

*** Running R inside source code chunks in org files

    I like to create code notebooks in Org-mode files. To do this, I
    use the following syntax for R (if I want to see the output right
    below the chunk)[fn:16]:

    #+begin_example
   #+begin_src R :session output
    <code>
   #+end_src
    #+end_example

    And now I can run the ~<code>~ inside the chunk with ~C-o C-o~, or
    I can open the code in a separate buffer and e.g. save it as an R
    file.
    
** My Emacs setup

   * The configuration file for Emacs is the ~.emacs~ file. [[https://1drv.ms/u/s!AhEvK3qWokrvitxPQ2OuaCOOQDfvZQ?e=KhLQW6][Here is
     the ~.emacs~ file that I use for download]].
   * Site lisp files are stored in ~/.emacs.d/~ and they are
     downloaded from a central repository. Emacs knows which ones to
     use. You can see all available and installed packages with the
     command ~M-x package-list-packages~.

* How to use GitHub Desktop to backup your code to GitHub

  With GitHub, you develop locally, and collaborate remotely. Even if
  you don't collaborate but only use GitHub as a repository as I do
  for our courses, it is useful: I don't need to worry about setting
  up a separate backup to a cloud location with complicated sharing
  rules. Once I make local changes, I can push them to the remote main
  repo. And if someone improves my remote repo (via the issue-branch
  mechanism of Git), I can pull the code and merge it with my local
  code.

  All of this saves me tons of time - GitHub + Emacs + Org-mode (in
  Emacs) are my two or three main productivity tools to run a proper
  ship even with four or five courses in parallel, and with a fair
  amount of involvement and new developments[fn:15].

  To work with GitHub under Windows, the easiest way is to download
  GitHub desktop, and create a local copy of your remote repo, or the
  other way around, create a remote GitHub repo from your local
  folder.

  Using the GitHub desktop does not replace the command line (CLI)
  use, which gives you more flexibility, but for my purpose, it
  suffices.

  /Image: GitHub desktop screenshots/

  1) I made a local change to ~FAQ.org~ which is monitored by Git. I
     click "commit" to indicate that I want the change to become
     permanent.

     #+attr_html:       :width 600px
     [[./img/github.png]]

  2) Git suggests that I push the changed file to the remote
     repository, which is by default called ~origin~. The remote repo
     currently looks at the ~main~ branch (that's the head - I can
     change that to another branch if it exists).

     #+attr_html:       :width 600px
     [[./img/github1.png]]

  3) After entering a summary of my change, I can execute the
     push. Git now informs me that there are no local changes
     pending.

     #+attr_html: :width 600px
     [[./img/github2.png]]

** Important files

   * ~README.md~ is a markdown file that automatically opens when you
     open the repo - it's like an index file.
   * ~.gitignore~ is a file with those files that you don't want to
     version control - like backup files or intermediate files
     (e.g. ~.dvi~ when you process a LaTeX file).

* How can you always create a great presentation?

  Here are some things people might say when asked what makes a
  presentation good, i.e. worth listening to:
  
  | WHAT     | HOW                      | WHEN   |
  |----------+--------------------------+--------|
  | Facts    | Validation & Relevance   | Always |
  | Story    | Message, Plot, Character | Always |
  | Delivery | Body and Soul            | Always |

  But what makes a presentation "great" (i.e. highly memorable,
  unforgettable, totally inspiring)?
  
  Barbara Minto's Pyramid Principle ([[minto][Minto, 2002]]) has a claim to being
  the method to achieve this. Here is an illustration followed by an
  example below.

  #+attr_html: :width 700px
  [[./img/minto.png]]

  (Image source: [[minto1][powerusersoftwares.com, 2016]])
  
**  Minto Pyramid Principle

   The SCQA method is not the same as the pyramid principle, but it is
   the dominant technique to arrive at a pyramid structure for your
   presentation, paper, essay, or even email.
  
*** Situation ("What's going on?")

    * (Almost) nobody likes giving presentations
    * Especially among nerds/geeks
    * Presentations are performance-oriented
    * Since you'll have to present, focus on efficiency
    * Efficient group or audience communication = rapport[fn:17]

*** Complication ("What should we do?")

    Audience composition, presentation purpose, circumstances, cultural
    factors, timing, and many more attributes, vary wildly from one
    presentation to the next. To always create a winning presentation,
    one needs a set of rules that remain unchanged.

*** Question ("What's the problem?")

    Are there any invariants[fn:18], i.e. things, processes, attributes
    that remain unchanged from one presentation to the next?[fn:19]

*** Answer 

    Audience rapport is a relationship invariant for all
    presentations. According to Barbara Minto ([[minto][Minto, 2002]]), the SCQA
    method delivers an invariant structure for all presentations, to
    all audiences. I am inclined to agree with her[fn:20].

** Minto tutorial videos

   For a short overview see the video: [[https://vimeo.com/87537935][Harrison Metal (2014)]].

  For a lecture in 2 parts by me ([[birk][2016]]), see here:
  * Minto Pyramid Principle Part 1 - [[https://youtu.be/HrmBZQuCSzo][Introductory Stories]]
  * Minto Pyramid Principle Part 2 - [[https://youtu.be/k_FJXpYPbQY][What Audiences Want]] 

* References

  <<birk14>> [[https://drive.google.com/file/d/0B9ubV5NfnNPpdlNycWxkaTFQc1k/view?usp=sharing][Birkenkrahe M (2014). Using Storytelling Methods To
  Improve Emotion, Motivation and Attitude Of Students Writing
  Scientific Papers And Theses. In: Proceedings of the 13th IEEE
  Int. Conf. on Cognitive Informatics & Cognitive Computing, London,
  August 18-20, 2014.]]

  <<birk>> Birkenkrahe M (Feb 7, 2016). Minto Pyramid Principle Part
  1 - Introductory stories. [[https://youtu.be/HrmBZQuCSzo][Online: youtube.com.]]

  Birkenkrahe M (Feb 7, 2016). Minto Pyramid Principle Part
  2 - What audiences want. [[https://youtu.be/k_FJXpYPbQY][Online: youtube.com.]]
  
  <<minto>> Minto B (2002). The Pyramid Principle. 

  Harrison Metal (2014). Storytelling & Presenting 1: Thank You,
  Barbara Minto [video]. [[https://vimeo.com/87537935][Online: vimeo.com]]

  <<minto1>> Power-user (Jul 31, 2016). Give a brilliant structure to
  your presentations with the Pyramid Principle [website]. [[https://www.powerusersoftwares.com/post/2016/07/31/give-a-brilliant-structure-to-your-presentations-with-the-pyramid-principle][Online:
  powerusersoftwares.com]]
  
* Footnotes

[fn:20]As a Shell manager, I had the opportunity to learn the method
first hand from Barbara Minto herself (as you can hear in one of my
two short videos). 

[fn:19]Some of the items that I mentioned and asked for certainly are
not invariant: quantification, prioritized bullet points, less is more
on the page etc. - all of these do depend on audiences and topic!
Still, as university students, now and later, you're more likely to
have to report on numbers in a systematic, minimal way, hence these
suggestions are still useful.

[fn:18]Invariants in physics and mathematics is anything that does not
change under transformation, from one reference frame to another.  

[fn:17]"Rapport is a close and harmonious relationship in which the
people or groups concerned are "in sync" with each other, understand
each other's feelings or ideas, and communicate smoothly." ([[https://en.wikipedia.org/wiki/Rapport][Wikipedia]])
 
[fn:16]This would work for any language that Emacs supports, which is
pretty much every programming language in existence. 

[fn:15]If you never make any changes you don't need to watch
productivity, because you can just regurgitate old stuff. However,
personally, I would get bored to death.

[fn:14]"Forking" means that you create an active copy of the repo in
your own workspace. Whenever the owner makes changes to the forked
repo, you'll be notified so that you can follow the change ("fetch
upstream").

[fn:13]The difference between "discussion" and "issue" is that the
latter suggests a change or a comment by the developers. Discussions
on the other hand are free form.

[fn:12]Once you register, you'll be asked to complete the "[[https://guides.github.com/activities/hello-world/][Hello
World]]" activity - do it - takes 15 minutes of your time!

[fn:11]You will then be a "collaborator" on my repo, which means that
you can raise issues, discuss, upload files, create branches, and make
pull requests.

[fn:10]There's something else worth noticing: this article, as most
articles on the web, are written by self starters and by independent
students or scholars. Nothing wrong with that but if you're lucky
enough to study at an institution, you can use experts around you to
find out about the best papers. These experts act like curators. For
example, I scan a lot of literature and will often pass interesting
articles on to you - like this one!

[fn:9]I received this online publication because I am subscribed to an
aggregator service. If you're not subscribed, you only have a limited
number of articles that you can view for free.

[fn:8]I do this in Emacs using [[https://magit.vc/][Magit]], a text-based user interface to
Git.

[fn:7]About that: most texts are not well written. Students often
feel it but don't know it for sure - but if a text does not speak to
you even though you honestly want to learn, it is more likely the
fault of its author. Or it could be that you need to read it not on a
digital device - I e.g. need to read mathematical texts on paper - I
cannot follow when I only see it displayed on a screen. If you cannot
find a well written text, try to write one yourself! Many excellent
books by excellent people were created that way (I should cite
examples here, but this is anecdotal knowledge - I should look it up,
or you could look it up and let me know).

[fn:6]Though in the case of the abovementioned online course, the
reason is that the course is quite boring, so I use the props to keep
myself entertained. If coding is not entertaining to you, something
else may be, e.g. making mindmaps or recording a log of what you
learnt, or doodling.

[fn:5]For the abovementioned online course on basic probability using
R, I fired up my R program and type examples into the console as I
listen to the lecture, and when I summarize it. If I work out a
lecture, I use my trusty Emacs editor to write an Org-mode file, which
includes code chunks, a concept and a code summary.

[fn:4]It doesn't have to be rocket science: recently, I took an online
course on basic probability. Since I had not looked at the material
for a long time, I had lost all mathematical intuition, and I had to
write down every example mentioned in the instruction video, to
recover at least some of it.

[fn:1]This is a principle of utility, which you will recognize as a
guiding principle for AI, especially for autonomous agents. Even if
you don't subscribe to it, you need to understand it.

[fn:3]I don't know about your attention span, but my attention span is
atrociously short: I always have so much running through my mind that
I am easily off on another thought-road. They say that this has to do
with the increasing use of digital tools and the web etc. but I think
it is much more down to individual psychology, constitution, or brain
chemistry. In any case: it's not an bug, but a feature! As always when
you identify one of your features, you should think about making best
use of it. Short attention span, for example, requires you to impose
structure and discipline on your learning plan and your day. And more
than that, it doesn't only distract you but it also re-orients you
quickly, so you're probably able to deal with more stimulation than
other people.

[fn:2]For example, as I am writing this, I'm watching "[[https://techtv.mit.edu/videos/10268-the-thinking-machine-1961---mit-centennial-film][The Thinking
Machine]]" (53 min. 1961). It's fascinating, but as I'm skimming
(i.e. listening to the first few minutes, looking at reviews ([[https://www.fastcompany.com/90399709/to-understand-ai-in-2019-watch-this-1960-tv-show][like
this one from 2019]]) or secondary sources to validate the content (who
are the authors? Whom does this text serve? When was it written? Where
was it published?), and going to two or three places in the film (to
see if the initial quality holds), I realize that I will have to dive
more deeply into this material - the equivalent of reading type (4)
where I take notes, jot down questions and my own ideas, perhaps even
branch into (5) and use a prop like a mindmap. If I go there or not
will depend on a number of factors: time available, alternative
sources, my mood, the weather, other priorities, etc.
